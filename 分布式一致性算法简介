
一致性问题可以分为两个问题
    1、 任何一次修改保证数据的一致性
    2、 多次数据修改的一致性
弱一致性算法，不要求每次修改内容在修改后多副本的内容是一致的。 对于问题2，只要保证最终一致性，就可以。无所谓每次用于修改后的多副本的一致性。
只要求在单调的时间方向上，数据最终保持一致，如此可以获得极大的并发性能。

强一致性算法强调每一次修改后的结果多副本都要保持一致。
解决问题1 通常有两阶段提交算法、采用分布式锁服务和采用乐观锁原理实现的同步方式。
    1 两阶段提交算法
        在两阶段提交协议中，系统一般包括两类机器（或节点）：一类为协调者，通常一个系统中只有一个；一个为事务参与者，一般包括多个，
        可以理解为副本的个数。 两阶段提交协议有两个阶段组成，执行过程如下：
        （1）请求阶段（或者称表决阶段voting phase）
             请求阶段，协调者通知失误参与者准备提交或者取消事物，然后进入表决过程，参与者将告诉协调者自己的决策：同意（参与者本地作业执行成功）
             或者取消（本地作业执行故障）
         （2）提交阶段（commit phase）
              协调者给予第一阶段的投票结果进行决策：提交或者取消。当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，
              否则协调者通知所有的参与者取消事务。参与者收到消息，执行相关操作。
    在该过程中可能存在通信失败，例如网络中断、主机宕机等诸多的原因，对于未在算法中定义的其它异常，都认为是提交失败，都需要回滚，
    这是该算法基于确定的通信回复实现的，在参与者的确定回复（无论是回复失败还是回复成功）之上执行逻辑处理，
    符合确定性的条件当然能够获得确定性的结果哲学原理。
    
    2 分布式锁服务
        分布式锁是对数据被外界修改持保守态度，在整个数据处理过程中将数据处于锁定状态，在用户修改数据的同时，其它用户不允许修改。
      采用分布式锁服务实现数据一致性，是在操作目标之前先获取操作许可，然后再执行操作，如果其他用户同时尝试操作该目标将被阻止，
      直到前一个用户释放许可后，其他用户才能够操作目标。分析这个过程，如果只有一个用户操作目标，没有多个用户并发冲突，
      也申请了操作许可，造成了由于申请操作许可所带来的资源使用消耗，浪费网络通信和增加了延时。
      采用分布式锁实现多副本内容修改的一致性问题， 选择控制内容颗粒度实现申请锁服务。
      例如我们要保证一个文件的多个副本修改一致， 可以对整个文件修改设置一把锁，修改时申请锁，修改这个文件的多个副本，
      确保多个副本修改的一致，修改完成后释放锁；也可以对文件分段，或者是文件中的单个字节设置锁， 实现更细颗粒度的锁操作，减少冲突。
      
  3 乐观锁
      读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，
      如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 zookeeper大量使用乐观锁
  
  
  

